from pydantic import BaseModel, EmailStr, UUID4, Field
from datetime import datetime, timedelta, date
from typing import Dict, Union, Optional
import pytz



class UserSnapshotResponse(BaseModel):
    event_time: datetime
    event_type: str
    event_metadata: Dict

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2

# User Schemas
class UserCreate(BaseModel):
    email: EmailStr
    event_time: Optional[datetime] = None

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


class UserDeactivate(BaseModel):
    identifier: Union[EmailStr, str]
    event_time: Optional[datetime] = None

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


class UserResponse(BaseModel):
    user_id: UUID4
    email: EmailStr
    event_time: datetime

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2

class UserSnapshot(BaseModel):
    event_time: Optional[datetime] = None

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2



# Shop Schemas
class ShopCreate(BaseModel):
    user_id: UUID4
    shop_name: str
    event_time: Optional[datetime] = None

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


class ShopResponse(BaseModel):
    shop_id: UUID4
    user_id: UUID4
    shop_name: str
    event_time: datetime

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


class ShopDelete(BaseModel):
    shop_id: UUID4
    user_id: Optional[UUID4] = None  # Optional, depending on your business logic
    event_time: Optional[datetime] = None

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


# Global Event Schemas
class GlobalEventCreate(BaseModel):
    event_type: str  # Assuming `models.EventType` is a string type
    event_metadata: Dict

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


class GlobalEventResponse(BaseModel):
    event_id: str  # Convert UUID to string
    event_time: datetime
    event_type: str  # Convert Enum to string
    event_metadata: Dict

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


# Invoice Schemas
class InvoiceCreate(BaseModel):
    user_id: UUID4
    shop_id: UUID4
    invoice_amount: float
    event_time: Optional[datetime] = Field(default_factory=datetime.utcnow)

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


class UserInvoice(BaseModel):
    invoice_id: Optional[UUID4]  # Optional because it will be generated by the database
    user_id: UUID4
    shop_id: UUID4
    invoice_amount: float
    event_time: datetime = Field(default_factory=datetime.utcnow)
    partition_key: date

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


# Payment Schemas
class PaymentCreate(BaseModel):
    invoice_id: UUID4
    payment_amount: float
    event_time: Optional[datetime] = Field(default_factory=datetime.utcnow)

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


class Payment(BaseModel):
    payment_id: Optional[UUID4]  # Optional because it will be generated by the database
    invoice_id: UUID4
    payment_amount: float
    event_time: datetime = Field(default_factory=datetime.utcnow)
    partition_key: date

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


# Fake Data Query Schema
class FakeDataQuery(BaseModel):
    start_date: datetime = Field(default_factory=lambda: (datetime.now(pytz.utc) - timedelta(days=14)).replace(hour=0, minute=0, second=0, microsecond=0))
    end_date: datetime = Field(default_factory=lambda: (datetime.now(pytz.utc) - timedelta(days=1)).replace(hour=23, minute=59, second=59, microsecond=999999))
    max_fake_users_per_day: Optional[int] = 1000
    max_user_churn: Optional[float] = 0.1
    max_first_shop_creation_percentage: Optional[float] = 0.9
    max_multiple_shop_creation_percentage: Optional[float] = 0.2
    max_shop_churn: Optional[float] = 0.2

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2
        json_schema_extra = {
            "example": {
                "start_date": "2024-08-10T01:27:57.369Z",
                "end_date": "2024-08-16T01:27:57.369Z",
                "max_fake_users_per_day": 1000,
                "max_user_churn": 0.1,
                "max_first_shop_creation_percentage": 0.8,
                "max_multiple_shop_creation_percentage": 0.1,
                "max_shop_churn": 0.2
            }
        }


# New User Schema
class User(BaseModel):
    id: UUID4
    status: bool = True
    created_time: datetime
    deactivated_time: Optional[datetime] = None
    partition_key: date

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2


# New Shop Schema
class Shop(BaseModel):
    id: UUID4
    shop_owner_id: UUID4
    shop_name: str
    created_time: datetime
    deactivated_time: Optional[datetime] = None

    class Config:
        from_attributes = True  # Updated from orm_mode to from_attributes as per Pydantic v2
